//includes
#include <stdio.h>
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>
#include "mcc_generated_files/system/system.h"
#include <stdbool.h>
#include "mcc_generated_files/timer/delay.h"
//library includes
#include "mirf.h"
#include "led_matrix.h"
#include "led_shift.h"

#define CONFIG_SLAVE 1
#define CONFIG_RADIO_CHANNEL 112
#define CONFIG_ADVANCED 1
#define CONFIG_RF_RATIO_1M 1
#define CONFIG_RETRANSMIT_DELAY 100

//global variables
bool nrf_flag=false;
volatile uint8_t currentRow = 0;
volatile uint8_t currentCol = 0;
volatile uint8_t currentMode = 0; // 0 = Red, 1 = Blue, 2 = Green

//interrupt to test the matrix
void led_toggle() {
    switch (currentMode) {
        case 0: // Red state: Set LEDs to red one by one
            setLEDToRed(currentRow, currentCol);
            setLEDToRed_Matrix2(currentRow, currentCol); // Matrix 2
            break;
        case 1: // Blue state: Reset all LEDs to blue at once
            if (currentRow == 0 && currentCol == 0) {
                initLEDMatrixBlue();
                initLEDMatrixBlue_Matrix2(); // Matrix 2
            }
            break;
        case 2: // Green state: Set LEDs to green one by one
            setLEDToGreen(currentRow, currentCol);
            setLEDToGreen_Matrix2(currentRow, currentCol); // Matrix 2
            break;
    }

    // Advance column and row for red/green states
    if (currentMode != 1) {
        currentCol++;
        if (currentCol >= MATRIX_SIZE) {
            currentCol = 0;
            currentRow++;
            if (currentRow >= MATRIX_SIZE) {
                currentRow = 0;
                currentMode++;
                if (currentMode > 2) {
                    currentMode = 0; // Loop back to red state
//                    TMR0_Stop();
                }
            }
        }
    } else {
        // Move directly to the next mode after one blue reset
        currentMode++;
        if (currentMode > 2) {
            currentMode = 0; // Loop back to red state
        }
    }
}


//interrupt generated by irq pin of the nrf24
void nrf_irq(){
    nrf_flag=true;
}

#if CONFIG_ADVANCED
void AdvancedSettings(NRF24_t * dev)
{
#if CONFIG_RF_RATIO_2M
	Nrf24_SetSpeedDataRates(dev, 1);
#endif // CONFIG_RF_RATIO_2M

#if CONFIG_RF_RATIO_1M
	Nrf24_SetSpeedDataRates(dev, 0);
#endif // CONFIG_RF_RATIO_2M

#if CONFIG_RF_RATIO_250K
	Nrf24_SetSpeedDataRates(dev, 2);
#endif // CONFIG_RF_RATIO_2M
	Nrf24_setRetransmitDelay(dev, CONFIG_RETRANSMIT_DELAY);
}
#endif // CONFIG_ADVANCED

#if CONFIG_SLAVE
void slave(void *pvParameters) {
    NRF24_t dev;
    Nrf24_init(&dev);
    uint8_t payload = 32;
    uint8_t channel = CONFIG_RADIO_CHANNEL;
    Nrf24_config(&dev, channel, payload);

    // Set RX/TX addresses
    while (Nrf24_setRADDR(&dev, (uint8_t *)"3RECV") != NRF_OK);
    while (Nrf24_setTADDR(&dev, (uint8_t *)"3RECV") != NRF_OK);

#if CONFIG_ADVANCED
    AdvancedSettings(&dev);
#endif

    Nrf24_configRegister(NRF_STATUS, (1 << RX_DR) | (1 << TX_DS) | (1 << MAX_RT));
    TMR1_Stop();
    TMR2_Stop();
    TMR0_Stop();
    TMR4_Start();
    nRF24_IRQ_SetInterruptHandler(nrf_irq);

    INTERRUPT_GlobalInterruptEnable();
    while (1) {


        // Ping logic
//        if (send_ping_flag) {
//            send_ping_flag = false;

//            uint8_t ping_buf[32] = "PING";
//            Nrf24_send(&dev, ping_buf);
//            while (Nrf24_isSending(&dev)) {
//                    DELAY_milliseconds(1);
//                }
////        }
        if(nrf_flag){
		if (Nrf24_dataReady(&dev)) {
            uint8_t buf[32] = {0};
			Nrf24_getData(&dev, buf);
            if (strncmp((char*)buf, "LED", 8) == 0) {
            // buf[0..7] = "LED" + padding
            // buf[8..27] = payload (20 bytes for two matrices)
            updateLedMatrices(&buf[8]);
            }
		}
        nrf_flag=false;
        }

        DELAY_milliseconds(10);  // Avoid watchdog
    }
}
#endif // CONFIG_SLAVE

#if CONFIG_RECEIVER
void receiver(void *pvParameters)
{
	    NRF24_t dev;
    Nrf24_init(&dev);
    uint8_t payload = 32;
    uint8_t channel = CONFIG_RADIO_CHANNEL;
    Nrf24_config(&dev, channel, payload);

    // Set RX/TX addresses
    while (Nrf24_setRADDR(&dev, (uint8_t *)"3RECV") != NRF_OK);
    while (Nrf24_setTADDR(&dev, (uint8_t *)"3RECV") != NRF_OK);
    

#if CONFIG_ADVANCED
	AdvancedSettings(&dev);
#endif // CONFIG_ADVANCED

	// Print settings
//	Nrf24_printDetails(&dev);

	uint8_t buf[32];

	// Clear RX FiFo
	while(1) {
		if (Nrf24_dataReady(&dev) == false) break;
		Nrf24_getData(&dev, buf);
	}
    nRF24_IRQ_SetInterruptHandler(nrf_irq);
    TMR1_Stop();
    TMR2_Stop();
    TMR0_Stop();
    TMR4_Stop();
    INTERRUPT_GlobalInterruptEnable();
//    initLEDMatrixBlue();
//    initLEDMatrixBlue_Matrix2();
    currentMode=1;
//    TMR3_Start();
    
    Nrf24_configRegister(NRF_STATUS, (1 << RX_DR) | (1 << TX_DS) | (1 << MAX_RT));

	while(1) {
		// Wait for received data
        if(nrf_flag){
		if (Nrf24_dataReady(&dev)) {
			Nrf24_getData(&dev, buf);
            if (strncmp((char*)buf, "LED", 8) == 0) {
            // buf[0..7] = "LED" + padding
            // buf[8..27] = payload (20 bytes for two matrices)
            updateLedMatrices(&buf[8]);
            }
		}
        }
		DELAY_milliseconds(1); // Avoid WatchDog alerts
	}
}
#endif // CONFIG_RECEIVER


#if CONFIG_SENDER
void sender(void *pvParameters)
{
	NRF24_t nrf;
	Nrf24_init(&nrf);
	uint8_t payload = 32;
	uint8_t channel = CONFIG_RADIO_CHANNEL;
	Nrf24_config(&nrf, channel, payload);

	// Set destination address using 5 characters
	int ret = Nrf24_setTADDR(&nrf, (uint8_t *)"FGHIJ");
	if (ret != NRF_OK) {
		while(1) { DELAY_milliseconds(1); }
	}

#if CONFIG_ADVANCED
	AdvancedSettings(&nrf);
#endif // CONFIG_ADVANCED

	// Print settings
	Nrf24_printDetails(&nrf);

	uint8_t buf[32] = "BATTLEFIELD.";
	while(1) {
		Nrf24_send(&nrf, buf);
		Nrf24_isSend(&nrf, 1000);
		DELAY_milliseconds(1);
	}
}
#endif // CONFIG_SENDER

void main(void)
{
    SYSTEM_Initialize();
//    TMR0_OverflowCallbackRegister(led_toggle);
    TMR2_OverflowCallbackRegister(LEDMatrix_TimerISR);
    TMR4_OverflowCallbackRegister(LEDMatrix_RowController_TimerISR);
//    TMR1_OverflowCallbackRegister(LEDMatrix2_TimerISR);
//    TMR0_OverflowCallbackRegister(LEDMatrix2_RowController_TimerISR);

    
#if CONFIG_SLAVE
    slave(NULL);
#endif
    
#if CONFIG_RECEIVER
	receiver(NULL);
#endif

#if CONFIG_SENDER
    sender(NULL);
#endif

}